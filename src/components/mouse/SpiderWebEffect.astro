<!-- 蜘蛛网背景特效 -->
 <!-- 参考: https://blog.csdn.net/ungoing/article/details/125071691 -->
<canvas id="spider-web-canvas"></canvas>

<style>
  #spider-web-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 32765;
    pointer-events: none;
    opacity: 0.17;
  }
</style>

<script>
  class SpiderWebEffect {
    private canvas: HTMLCanvasElement;
    private ctx: CanvasRenderingContext2D;
    private width: number;
    private height: number;
    private particles: WebParticle[] = [];
    private mouse: { x: number | null; y: number | null } = { x: null, y: null };
    private animationId: number | null = null;
    private time: number = 0;

    // 配置参数
    private config = {
      zIndex: 32765,
      opacity: 0.7,
      color: "255, 255, 255", // 白色蜘蛛网
      count: 120, // 粒子数量
      maxDistance: 25000, // 最大连接距离
      particleMaxDistance: 8000, // 粒子最大移动距离
      particleSize: 1.5, // 粒子大小
      lineWidth: 0.8, // 线条宽度倍数
      mouseInfluence: 0.04, // 鼠标影响力
      colorShift: true, // 是否启用颜色变化
      glowEffect: true // 是否启用发光效果
    };

    constructor() {
      this.canvas = document.getElementById('spider-web-canvas') as HTMLCanvasElement;
      this.ctx = this.canvas.getContext('2d')!;
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      
      this.init();
    }

    init(): void {
      this.updateSize();
      this.createParticles();
      this.bindEvents();
      this.startAnimation();
    }

    updateSize(): void {
      this.width = window.innerWidth;
      this.height = window.innerHeight;
      this.canvas.width = this.width;
      this.canvas.height = this.height;
    }

    createParticles(): void {
      this.particles = [];
      
      // 创建随机粒子
      for (let i = 0; i < this.config.count; i++) {
        const x = Math.random() * this.width;
        const y = Math.random() * this.height;
        const xa = (2 * Math.random() - 1) * 0.8; // x方向速度
        const ya = (2 * Math.random() - 1) * 0.8; // y方向速度
        const size = this.config.particleSize + Math.random() * 0.5;
        
        this.particles.push(new WebParticle(
          x, y, xa, ya, this.config.particleMaxDistance, size
        ));
      }
    }

    bindEvents(): void {
      // 鼠标移动事件
      window.addEventListener('mousemove', (e: MouseEvent) => {
        this.mouse.x = e.clientX;
        this.mouse.y = e.clientY;
      });

      // 鼠标离开事件
      window.addEventListener('mouseout', () => {
        this.mouse.x = null;
        this.mouse.y = null;
      });

      // 触摸事件支持
      window.addEventListener('touchmove', (e: TouchEvent) => {
        const touch = e.touches[0];
        this.mouse.x = touch.clientX;
        this.mouse.y = touch.clientY;
      });

      window.addEventListener('touchend', () => {
        this.mouse.x = null;
        this.mouse.y = null;
      });

      // 窗口大小改变
      window.addEventListener('resize', () => {
        this.updateSize();
        this.createParticles(); // 重新创建粒子以适应新尺寸
      });
    }

    startAnimation(): void {
      const animate = () => {
        this.time += 0.016;
        this.update();
        this.draw();
        this.animationId = requestAnimationFrame(animate);
      };
      animate();
    }

    update(): void {
      // 更新所有粒子位置
      this.particles.forEach(particle => {
        particle.update(this.width, this.height, this.time);
      });
    }

    draw(): void {
      // 清空画布
      this.ctx.clearRect(0, 0, this.width, this.height);
      
      // 绘制粒子和连接线
      this.particles.forEach((particle, index) => {
        // 绘制粒子
        const particleColor = this.getParticleColor(particle, index);
        this.ctx.fillStyle = particleColor;
        this.ctx.fillRect(
          particle.x - particle.size / 2, 
          particle.y - particle.size / 2, 
          particle.size, 
          particle.size
        );
        
        // 绘制连接线
        for (let j = index + 1; j < this.particles.length; j++) {
          const otherParticle = this.particles[j];
          const distance = this.getDistance(particle, otherParticle);
          
          if (distance < this.config.maxDistance) {
            const opacity = (this.config.maxDistance - distance) / this.config.maxDistance;
            const lineWidth = opacity * this.config.lineWidth;
            
            this.ctx.beginPath();
            this.ctx.lineWidth = lineWidth;
            this.ctx.strokeStyle = this.getLineColor(opacity, index, j);
            this.ctx.moveTo(particle.x, particle.y);
            this.ctx.lineTo(otherParticle.x, otherParticle.y);
            this.ctx.stroke();
          }
        }
        
        // 绘制与鼠标的连接线
        if (this.mouse.x !== null && this.mouse.y !== null) {
          const mousePos = { x: this.mouse.x, y: this.mouse.y };
          const distance = this.getDistance(particle, mousePos);
          
          if (distance < this.config.maxDistance) {
            const opacity = (this.config.maxDistance - distance) / this.config.maxDistance;
            
            // 鼠标吸引粒子
            if (distance >= this.config.maxDistance / 2) {
              particle.x -= this.config.mouseInfluence * (particle.x - this.mouse.x);
              particle.y -= this.config.mouseInfluence * (particle.y - this.mouse.y);
            }
            
            // 绘制连接线
            this.ctx.beginPath();
            this.ctx.lineWidth = opacity * this.config.lineWidth;
            this.ctx.strokeStyle = this.getMouseLineColor(opacity, index);
            this.ctx.moveTo(particle.x, particle.y);
            this.ctx.lineTo(this.mouse.x, this.mouse.y);
            this.ctx.stroke();
          }
        }
      });
    }

    getParticleColor(particle: WebParticle, index: number): string {
      if (this.config.colorShift) {
        const hue = (index * 137.5 + this.time * 20) % 360;
        return `hsl(${hue}, 70%, 80%)`;
      }
      return `rgba(${this.config.color}, 0.9)`;
    }

    getLineColor(opacity: number, index1: number, index2: number): string {
      if (this.config.colorShift) {
        const hue = ((index1 + index2) * 137.5 + this.time * 10) % 360;
        return `hsla(${hue}, 70%, 70%, ${opacity + 0.1})`;
      }
      return `rgba(${this.config.color}, ${opacity + 0.1})`;
    }

    getMouseLineColor(opacity: number, index: number): string {
      if (this.config.colorShift) {
        const hue = (index * 137.5 + this.time * 15) % 360;
        return `hsla(${hue}, 80%, 80%, ${opacity + 0.2})`;
      }
      return `rgba(${this.config.color}, ${opacity + 0.2})`;
    }

    getDistance(p1: WebParticle, p2: { x: number; y: number }): number {
      const dx = p1.x - p2.x;
      const dy = p1.y - p2.y;
      return dx * dx + dy * dy;
    }

    destroy(): void {
      if (this.animationId) {
        cancelAnimationFrame(this.animationId);
      }
    }
  }

  class WebParticle {
    public x: number;
    public y: number;
    public xa: number;
    public ya: number;
    public max: number;
    public size: number;
    private originalSize: number;

    constructor(x: number, y: number, xa: number, ya: number, max: number, size: number) {
      this.x = x;
      this.y = y;
      this.xa = xa;
      this.ya = ya;
      this.max = max;
      this.size = size;
      this.originalSize = size;
    }

    update(width: number, height: number, time: number): void {
      // 更新位置
      this.x += this.xa;
      this.y += this.ya;
      
      // 边界碰撞检测
      if (this.x > width || this.x < 0) {
        this.xa *= -1;
      }
      if (this.y > height || this.y < 0) {
        this.ya *= -1;
      }
      
      // 粒子大小呼吸效果
      this.size = this.originalSize + Math.sin(time * 2 + this.x * 0.01) * 0.3;
    }
  }

  // 页面加载完成后初始化特效
  document.addEventListener('DOMContentLoaded', () => {
    new SpiderWebEffect();
  });

  // 如果页面已经加载完成，直接初始化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      new SpiderWebEffect();
    });
  } else {
    new SpiderWebEffect();
  }
</script>
